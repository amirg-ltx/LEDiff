
def rgb_to_luminance(self, image_tensor):
    # 使用加权求和方法将 RGB 转换为灰度
    luminance = 0.299 * image_tensor[:, 0, :, :] + 0.587 * image_tensor[:, 1, :, :] + 0.114 * image_tensor[:, 2, :, :]
    return luminance.unsqueeze(1)  # [N, 1, H, W]

def compute_illumination(self, luminance, kernel_size=15, sigma=3):
    # 生成高斯核 (均值滤波的替代方法)
    padding = kernel_size // 2
    gaussian_filter = torch.ones((1, 1, kernel_size, kernel_size)).to(luminance.device) / kernel_size ** 2
    illumination = F.conv2d(luminance, gaussian_filter, padding=padding)
    return illumination

def retinex_decomposition(self, image_tensor, image_tensor_rec):
    # Step 1: 提取亮度 (luminance)
    luminance = self.rgb_to_luminance(image_tensor)
    luminance_rec = self.rgb_to_luminance(torch.exp(image_tensor_rec))
    
    # Step 2: 计算光照 (illumination)
    illumination = self.compute_illumination(luminance, kernel_size=self.retinex_kernel_size, sigma=self.retinex_sigma)
    illumination_rec = self.compute_illumination(luminance_rec, kernel_size=self.retinex_kernel_size, sigma=self.retinex_sigma)
    
    # Step 3: 转到log域
    log_image = torch.log(image_tensor + 1e-5)  # 防止log(0)
    log_illumination = torch.log(illumination + 1e-5)
    log_illumination_rec = torch.log(illumination_rec)
    
    # Step 4: 将log_illumination 复制三次以匹配RGB通道
    log_illumination = log_illumination.repeat(1, 3, 1, 1)  # [N, 3, H, W]
    log_illumination_rec = log_illumination_rec.repeat(1, 3, 1, 1)  # [N, 3, H, W]   
    
    # Step 5: 计算反射率 (reflectance) 在log域中
    log_reflectance = log_image - log_illumination
    log_reflectance_rec = image_tensor_rec - log_illumination_rec
    
    return log_reflectance, log_illumination, log_reflectance_rec, log_illumination_rec

  